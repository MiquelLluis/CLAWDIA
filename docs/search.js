window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "clawdia", "modulename": "clawdia", "kind": "module", "doc": "<p>CLAWDIA: Classification of Waves via Dictionary-based Algorithms</p>\n\n<p>CLAWDIA is a modular pipeline for analyzing gravitational-wave (GW) data using\nSparse Dictionary Learning (SDL) techniques. It is designed to facilitate tasks\nsuch as denoising and classification, offering a flexible framework that can be\nused as an integrated pipeline or as standalone routines. The primary goal is\nto enhance GW signals by reducing noise and accurately classifying them based\non their astrophysical or instrumental origins.</p>\n\n<p>The workflow is divided into two stages:</p>\n\n<ol>\n<li><strong>Denoising</strong>: Reduces noise artifacts while preserving key features of the\nGW signals using dictionaries optimized for sparse reconstruction.</li>\n<li><strong>Classification</strong>: Classifies the enhanced signals into specific categories\nusing the Low-Rank Shared Dictionary Learning (LRSDL) model, which\nleverages patterns learned during the denoising stage.</li>\n</ol>\n\n<p>CLAWDIA's modular design ensures it can adapt to a wide range of applications,\nmaking it a versatile tool for gravitational-wave data analysis.</p>\n\n<h6 id=\"submodules\">Submodules</h6>\n\n<p>dictionaries : Classes and functions to handle dictionary models, including\n               SPAMS and LRSDL-based dictionaries, for Sparse Dictionary\n               Learning.\nestimators   : Tools for computing signal metrics such as mean squared error,\n               signal-to-noise ratio, and other statistical and\n               signal-processing metrics.\nlib          : Utility functions for mathematical operations, signal\n               normalization, and optimization routines.\npipeline     : A minimal implementation of CLAWDIA's classification pipeline,\n               assuming pre-trained dictionaries and configured parameters.\nplotting     : Visualization tools for debugging and presenting results, such\n               as dictionary atoms and confusion matrices.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>numpy</code>:  Fundamental package for numerical computations. <br />\n<code>scipy</code>:  Library for scientific computing with Python. <br />\n<code>sklearn</code>:  Machine learning framework used in CLAWDIA. <br />\n<code>spams</code>:  Sparse Modeling Software for dictionary learning and sparse coding.  </p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>CLAWDIA was developed as part of the PhD thesis _Gravitational-wave signal\ndenoising, reconstruction and classification via sparse dictionary\nlearning_ (2025).</li>\n<li>Future updates will address enhancements to dictionary training and\nmodularization of utility functions to improve usability and performance.</li>\n</ul>\n"}, {"fullname": "clawdia.dictionaries", "modulename": "clawdia.dictionaries", "kind": "module", "doc": "<p>Main module for managing all SDL models.</p>\n\n<p>This module serves as the central interface for handling dictionary models \nincluded in the CLAWDIA pipeline. It provides classes and functions to load, \nsave, and manage different types of dictionary models used in Sparse Dictionary \nLearning (SDL). Support is included for both SPAMS-based dictionaries and \nLow-Rank Sparse Dictionary Learning (LRSDL) models, ensuring compatibility and \nease of use.</p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams", "kind": "class", "doc": "<p>Sparse Dictionary Learning (SDL) model for waveform denoising via SPAMS.</p>\n\n<p>This class provides an object-oriented implementation of a Sparse\nDictionary Learning model, designed for the denoising and reconstruction\nof waveforms. At its core, it utilizes the <code>trainDL</code> function for\ndictionary learning and the <code>lasso</code> function for sparse coding from the\nSPAMS-python library [1].</p>\n\n<p>It extends these core functionalities to arbitrarily long signals and\nminibatch processing for large datasets. Additionally, the class includes\nvarious utilities for signal preprocessing, composite models of denoising\n(such as iterative reconstruction), and the ability to easily save and\nload the dictionary's state.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>dict_init</strong> (ndarray):\nAtoms of the initial dictionary. Remains unaltered after training.</li>\n<li><strong>components</strong> (ndarray):\nAtoms of the current (trained) dictionary.</li>\n<li><strong>model</strong> (tuple):\nSPAMS' trainDL model components in the form (A, B, iter).</li>\n<li><strong>d_size</strong> (int):\nNumber of atoms in the dictionary (dictionary size).</li>\n<li><strong>a_length</strong> (int):\nLength of each atom in the dictionary (patch size).</li>\n<li><strong>lambda1</strong> (float):\nRegularization parameter for training the dictionary.</li>\n<li><strong>batch_size</strong> (int):\nBatch size used in mini-batch training.</li>\n<li><strong>n_iter</strong> (int):\nNumber of iterations performed during training.</li>\n<li><strong>t_train</strong> (float):\nTotal training time in seconds.</li>\n<li><strong>trained</strong> (bool):\nIndicates whether the dictionary has been trained.</li>\n<li><strong>n_train</strong> (int):\nNumber of patches used during training.</li>\n<li><strong>mode_traindl</strong> (int):\nTraining mode for SPAMS' <code>trainDL</code> function.</li>\n<li><strong>modeD_traindl</strong> (int):\nDictionary mode for SPAMS' <code>trainDL</code> function.</li>\n<li><strong>mode_lasso</strong> (int):\nMode for SPAMS' <code>lasso</code> function.</li>\n<li><strong>identifier</strong> (str):\nOptional identifier or note for distinguishing the dictionary.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] SPAMS (for python),\n    (http://spams-devel.gforge.inria.fr/).\n    Last accessed in October 2018.</p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.__init__", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.__init__", "kind": "function", "doc": "<p>Initialize the dictionary.</p>\n\n<p>There are two ways to initialize the dictionary:</p>\n\n<ol>\n<li>By directly providing the initial dictionary with <code>dict_init</code>.</li>\n<li>By providing a collection of signals (<code>signal_pool</code>) from which atoms\nare randomly extracted to form the initial dictionary.</li>\n</ol>\n\n<p>If the second option is used, <code>a_length</code> and <code>d_size</code> must be explicitly\nspecified to define the size of the dictionary. Additional optional\nparameters provide more control over this process.</p>\n\n<h6 id=\"note\">Note</h6>\n\n<p>This method initializes the dictionary but does not train it. Use the\n<code>train</code> method for training.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dict_init</strong> (ndarray of shape (d_size, a_length), optional):\nAtoms of the initial dictionary. If None, <code>signal_pool</code> must be provided.</li>\n<li><strong>model</strong> (dict, optional):\nSPAMS' <code>trainDL</code> model components as a dictionary with elements\n{A, B, iter}. Must be provided if continuing training from a previous state.</li>\n<li><strong>signal_pool</strong> (ndarray of shape (n_signals, n_samples), optional):\nA collection of signals from which atoms are extracted to form the\ninitial dictionary. Ignored if <code>dict_init</code> is provided.</li>\n<li><strong>a_length</strong> (int, optional):\nLength of each atom in the dictionary (patch size). Required if\n<code>signal_pool</code> is provided.</li>\n<li><strong>d_size</strong> (int, optional):\nNumber of atoms in the dictionary. Required if <code>signal_pool</code> is provided.</li>\n<li><strong>wave_pos</strong> (array-like of shape (n_signals, 2), optional):\nPositions of waveforms within <code>signal_pool</code> to extract atoms from. If\nNone, the entire array is used.</li>\n<li><strong>patch_min</strong> (int, default=1):\nMinimum number of samples for each extracted patch. Ignored if\n<code>wave_pos</code> is None.</li>\n<li><strong>l2_normed</strong> (bool, default=True):\nIf True, normalize extracted atoms to their L2 norm.</li>\n<li><strong>allow_allzeros</strong> (bool, default=True):\nIf False, random atoms with all zeros are not included in the initial\ndictionary.</li>\n<li><strong>random_state</strong> (int, optional):\nSeed for random sampling from <code>signal_pool</code>.</li>\n<li><strong>ignore_completeness</strong> (bool, optional):\nIf False, the dictionary must be overcomplete (<code>d_size &gt; a_length</code>).\nDefaults to False.</li>\n<li><strong>lambda1</strong> (float, optional):\nRegularization parameter for training.</li>\n<li><strong>batch_size</strong> (int, default=64):\nBatch size used during training.</li>\n<li><strong>n_iter</strong> (int, optional):\nTotal number of iterations for training. If None, this must be set when\ncalling the <code>train</code> method.</li>\n<li><strong>n_train</strong> (int, optional):\nNumber of patches used for training. Informational only.</li>\n<li><strong>trained</strong> (bool, default=False):\nIndicates whether the dictionary is already trained.</li>\n<li><strong>mode_traindl</strong> (int, default=0):\nTraining mode for SPAMS' <code>trainDL</code> function. See SPAMS documentation.</li>\n<li><strong>modeD_traindl</strong> (int, default=0):\nDictionary mode for SPAMS' <code>trainDL</code> function. See SPAMS documentation.</li>\n<li><strong>mode_lasso</strong> (int, default=2):\nMode for SPAMS' <code>lasso</code> function. See SPAMS documentation.</li>\n<li><strong>identifier</strong> (str, optional):\nA note or label for identifying the dictionary.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<p><code>train</code>:  Method to train the dictionary. <br />\n<code>reconstruct</code>:  Method to reconstruct signals using the dictionary.  </p>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] SPAMS (for python), (http://spams-devel.gforge.inria.fr/).\n    Last accessed in October 2018.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dict_init</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">signal_pool</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">a_length</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">d_size</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wave_pos</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">patch_min</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">l2_normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_allzeros</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_completeness</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">lambda1</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">n_iter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_train</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">trained</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">mode_traindl</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">modeD_traindl</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">mode_lasso</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">identifier</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span>)</span>"}, {"fullname": "clawdia.dictionaries.DictionarySpams.model", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.dict_init", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.dict_init", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.components", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.components", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.a_length", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.a_length", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.d_size", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.d_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.lambda1", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.lambda1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.batch_size", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.batch_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.n_iter", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.n_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.t_train", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.t_train", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.trained", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.trained", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.n_train", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.n_train", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.mode_traindl", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.mode_traindl", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.modeD_traindl", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.modeD_traindl", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.mode_lasso", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.mode_lasso", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.identifier", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.identifier", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionarySpams.train", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.train", "kind": "function", "doc": "<p>Train the dictionary.</p>\n\n<p>Train the dictionary with the given patches.</p>\n\n<p>This also allows a warm start using the previous components as initial\ndictionary, but only if the lambda1 parameter is the same. It can be\nthought of as adding more iterations to the training. Hence, providing\ndifferent patches is discouraged and untested.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>patches</strong> (2d-array(signals, samples)):\nTraining patches.</li>\n<li><strong>lambda1</strong> (float, optional):\nRegularization parameter of the learning algorithm.\nIt is not needed if already specified at initialization.</li>\n<li><strong>n_iter</strong> (int, optional):\nTotal number of iterations to perform.\nIf a negative number is provided it will perform the computation\nduring the corresponding number of seconds.\nFor instance <code>n_iter = -5</code> trains the dictionary during 5 seconds.</li>\n<li><strong>warm_start</strong> (bool):\nIf True, use the previous components as initial dictionary.\nIt can be thought of as adding more iterations to the training.\nProviding different patches is discouraged and untested.</li>\n<li><strong>verbose</strong> (bool, optional):\nIf True print the iterations (might not be shown in real time).</li>\n<li><strong>threads</strong> (int, optional):\nNumber of threads to use during training, see [1].</li>\n<li><strong>**kwargs</strong>: Passed directly to 'spams.trainDL', see [1].</li>\n<li><strong>Additional parameters will be passed to the SPAMS training function.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">patches</span>,</span><span class=\"param\">\t<span class=\"n\">lambda1</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_iter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">warm_start</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">threads</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reconstruct", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reconstruct", "kind": "function", "doc": "<p>Reconstruct a signal as a sparse combination of dictionary atoms.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>signal</strong> (ndarray):\nSample to be reconstructed.</li>\n<li><strong>sc_lambda</strong> (float):\nRegularization parameter of the sparse coding transformation.</li>\n<li><strong>step</strong> (int, 1 by default):\nSample interval between each patch extracted from signal.\nDetermines the number of patches to be extracted. 1 by default.</li>\n<li><strong>normed</strong> (boolean, True by default):\nNormalize the result to the maximum absolute value.</li>\n<li><strong>with_code</strong> (boolean, False by default.):\nIf True, also returns the coefficients array.</li>\n<li><strong>**kwargs</strong>: Passed directly to the external learning function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>signal_rec</strong> (array):\nReconstructed signal.</li>\n<li><strong>code</strong> (array(a_length, d_size), optional):\nTransformed data, encoded as a sparse combination of atoms.\nReturned when 'with_code' is True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">signal</span>,</span><span class=\"param\">\t<span class=\"n\">sc_lambda</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">with_code</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reconstruct_batch", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reconstruct_batch", "kind": "function", "doc": "<p>TODO</p>\n\n<p>Reconstruct multiple signals, each one as a sparse combination of\ndictionary atoms.</p>\n\n<p>WARNING: Only viable for small 'signals' set, it is really memory\nexpensive (all patches are stored in a single array in memory).</p>\n\n<p>WARNING: 'out' deprecated, left for backwards compatibility but will\nbe ignored if given.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">signals</span>,</span><span class=\"param\">\t<span class=\"n\">sc_lambda</span>,</span><span class=\"param\">\t<span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reconstruct_minibatch", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reconstruct_minibatch", "kind": "function", "doc": "<p>TODO</p>\n\n<p>Reconstruct multiple signals, each one as a sparse combination of\ndictionary atoms. Minibatch version.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">signals</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">sc_lambda</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batchsize</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">normed_windows</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reconstruct_auto", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reconstruct_auto", "kind": "function", "doc": "<p>TODO</p>\n\n<p>Reconstrueix un \u00fanic senyal buscant per bisecci\u00f3 la lambda que\nminimitza el senyal reconstruit al marge esquerre del senyal, la mida\ndels quals ve determinada per 'zero_marg'.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">signal</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">zero_marg</span>,</span><span class=\"param\">\t<span class=\"n\">lambda_lims</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">full_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs_bisect</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs_lasso</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reconstruct_iterative_minibatch", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reconstruct_iterative_minibatch", "kind": "function", "doc": "<p>Reconstruct multiple signals using iterative residual subtraction.</p>\n\n<p>This method reconstructs each signal by iteratively updating and\naccumulating reconstructions. In the first iteration, the original \ninput signal is reconstructed and then subtracted from itself to \nobtain the initial residual. In each subsequent iteration, a new \nreconstruction is generated from the current residual and subtracted \nfrom it, producing an updated residual for the next iteration, while \nalso being added to the cumulative reconstruction. The process \nrepeats until the Euclidean norm of the difference between consecutive \nresiduals falls below a specified threshold, which sets the convergence \ncriterion.</p>\n\n<p>NOTE: In contrast with the usual procedure, the windows into which each\nsignal is split are not normalized. This is needed to enhance the\ndictionary discrimination. Otherwise, the residuals are amplified at\neach iteration, the algorithm takes longer to converge, and some\nad-hoc tests showed it also messes up with the resulting shape.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>signals</strong> (ndarray):\nInput signals to be reconstructed, with each signal along the first dimension.</li>\n<li><strong>sc_lambda</strong> (float, optional):\nSparsity control parameter for reconstruction.</li>\n<li><strong>step</strong> (int, optional):\nStep size for the reconstruction.</li>\n<li><strong>batchsize</strong> (int, optional):\nNumber of signals processed in each minibatch.</li>\n<li><strong>max_iter</strong> (int, optional):\nMaximum number of iterations before stopping.</li>\n<li><strong>threshold</strong> (float, optional):\nConvergence threshold based on the relative change in residuals.</li>\n<li><strong>normed</strong> (bool, optional):\nIf True, the reconstructed signals are normalized after convergence.</li>\n<li><strong>full_output</strong> (bool, optional):\nIf True, returns additional output values (residuals and iteration counts).</li>\n<li><strong>verbose</strong> (bool, optional):\nIf True, prints progress information at each iteration.</li>\n<li><strong>kwargs_lasso</strong> (dict, optional):\nAdditional arguments for the Lasso reconstruction method.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ndarray or tuple</strong>: The final reconstructed signals. If <code>full_output</code> is True, also returns the residuals\nand the number of iterations per signal.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">signals</span>,</span><span class=\"param\">\t<span class=\"n\">sc_lambda</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batchsize</span><span class=\"o\">=</span><span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">full_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs_lasso</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.optimum_reconstruct", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.optimum_reconstruct", "kind": "function", "doc": "<p>Find the best reconstruction of a signal w.r.t. a reference.</p>\n\n<p>Find the lambda which produces a reconstruction of the\ninput 'strain' closest to the given 'reference', comparing them with\nthe SSIM estimator. The search is performed by the SciPy's function\n'minimize_scalar' with bounds.</p>\n\n<h6 id=\"parameters\">PARAMETERS</h6>\n\n<p>strain: ndarray\n    Input strain to be reconstructed (and optimized).</p>\n\n<p>reference: ndarray\n    Reference strain which to compare the reconstruction to.</p>\n\n<p>kwargs_minimize: dict\n    Passed to SciPy's <code>minimize_scalar(**kwargs_minimize)</code>.</p>\n\n<p>kwargs_lasso: dict\n    Passed to Python-Spams' <code>lasso(**kwargs_lasso)</code>.</p>\n\n<p>step: int, optional\n    Separation in samples between each window into which the input\n    strain is split up to be reconstructed by the dictionary. Defaults\n    to 1.</p>\n\n<p>limits: array-like, optional\n    Indices of limits to where compute the loss between the\n    reconstruction and the reference strain.</p>\n\n<p>normed: bool, optional\n    If True, returns the signal normed to its maximum absolute amplitude.</p>\n\n<p>verbose: bool, optional\n    Print info about the minimization results. False by default.</p>\n\n<h6 id=\"returns\">RETURNS</h6>\n\n<p>rec: ndarray\n    Optimum reconstruction found.</p>\n\n<p>l_opt: float\n    Optimum value for lambda.</p>\n\n<p>loss: float\n    ISSIM (1 - SSIM) between the optimized reconstruction and the\n    reference.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">strain</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs_minimize</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs_lasso</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">limits</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.save", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.save", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.copy", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.copy", "kind": "function", "doc": "<p>Return a copy of the dictionary.</p>\n\n<p>Returns a new instance of the same dictionary with the same values\nand state.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dico_copy</strong> (DictionarySpams):\nA copy of the current dictionary.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionarySpams.reset", "modulename": "clawdia.dictionaries", "qualname": "DictionarySpams.reset", "kind": "function", "doc": "<p>Reset the dictionary to its initial (untrained) state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL", "kind": "class", "doc": "<p>Interface for the Low-Rank Shared Dictionary Learning class.</p>\n\n<p>NOTE: The authors of Dictol didn't provide a seed parameter for the random\ninitialization of the dictionary. If reproducibility is important, one must\nset the global numpy's seed before callint LRSDL.__init__().</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>t_train</strong> (float):\nTraining time in seconds.</li>\n<li><strong>lambd</strong> (float):\nSee self.__init__() for details.</li>\n<li><strong>lambd2</strong> (float):\nSee self.__init__() for details.</li>\n<li><strong>eta</strong> (float):\nSee self.__init__() for details.</li>\n<li><strong>D</strong> (ndarray):\nClass-specific dictionary.</li>\n<li><strong>X</strong> (ndarray):\nClass-specific coefficient vector of the training set given when\ncalling self.fit().</li>\n<li><strong>Y</strong> (ndarray):\nClass-specific target vector (the training set) given when calling\nself.fit().</li>\n<li><strong>k</strong> (int):\nSee self.__init__() for details.</li>\n<li><strong>k0</strong> (int):\nSee self.__init__() for details.</li>\n<li><strong>updateX_iters</strong> (int):\nSee self.__init__() for details.</li>\n<li><strong>updateD_iters</strong> (int):\nSee self.__init__() for details.</li>\n<li><strong>D_range</strong> (list[int]):\nAuxiliar list containing the range of indices of each class in D.</li>\n<li><strong>D0</strong> (ndarray):\nShared dictionary.</li>\n<li><strong>Y_range</strong> (list[\u2192nt]):\nAuxiliar list containing the range of indices of each class in Y.\nDerived directly from 'train_label', equivalent to the 'y_true' labels.\nExample: given train_label = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], then\nY_range = [0, 4, 6]. The first value is always 0, marking the\nstart of the first class, and the last value is always the number of\nclasses + 1.</li>\n<li><strong>X0</strong> (ndarray):\nShared coefficient vector of the training set given when calling\nself.fit().</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>Vu, T. H.; Monga, V. (2017). Fast low-rank shared dictionary learning for image classification.\nIEEE Transactions on Image Processing, 26(11), 5160\u20135175. <a href=\"https://doi.org/10.1109/TIP.2017.2729885\">https://doi.org/10.1109/TIP.2017.2729885</a></p>\n", "bases": "dictol.LRSDL.LRSDL"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL.__init__", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL.__init__", "kind": "function", "doc": "<p>Initialize the dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lambd</strong> (float):\nRegularization term:\n    lambd * ||X||_1\nMakes the class-specific vector sparse, symilar to the LASSO\nregularization term.</li>\n<li><strong>lambd2</strong> (float):\nRegularization term:\n    lambd2 / 2 * ||X\u2070-M\u2070||\u00b2\nMakes the shared vector (selection of shared atoms) sparse and close to\nthe mean shared vector, i.e. all {X\u2070} close between them.</li>\n<li><strong>eta</strong> (float):\nRegularization term:\n    eta * ||D\u2070||_*\nEnforces the shared dictionary to be low-rank.</li>\n<li><strong>k</strong> (int):\nNumber of class-specific atoms for each class. The total number of\natoms in the class-specific dictionary is then <code>k * nc</code> where 'nc' is\nthe number of classes.</li>\n<li><strong>k0</strong> (int):\nTotal number of shared atoms. k0=0 is equivalent to the case when there\nis no shared dictionary.</li>\n<li><strong>updateX_iters, updateD_iters</strong> (int):\n<em>I think they are not used in this class at all.</em></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lambd</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">lambd2</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">eta</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">k0</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">updateX_iters</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">updateD_iters</span><span class=\"o\">=</span><span class=\"mi\">100</span></span>)</span>"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL.t_train", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL.t_train", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL.fit", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL.fit", "kind": "function", "doc": "<p>Train de LRSDL dictionary.</p>\n\n<p>Train the dictionary allowing several options:</p>\n\n<ul>\n<li>Split the strains in X into sliced windows of length equal to the\nlength of de dictionary, or</li>\n<li>use the whole strain as a window.</li>\n<li>Discard training windows whose L2-norm is below a threshold.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (2d-array, shape=(samples, features)):\nTraining samples, with equal or more features than the atoms'.</li>\n<li><strong>y_true</strong> (np.ndarray):\nLabels of samples in X, with <code>len(y_true) == X.shape[0]</code>.</li>\n<li><strong>l_atoms</strong> (int):\nLenght of the atoms of the dictionary.</li>\n<li><strong>iterations</strong> (int):\nNumber of training iterations.</li>\n<li><strong>step</strong> (int, optional):\nFor splitting strains in X into the specified 'l_atoms' in order to\ngenerate the training patches.\nNo splitting by default.</li>\n<li><strong>threshold</strong> (float, optional):\nL2-norm threshold relative to the window of max(L2-norm) of each\nstrain, below which to discard the rest of the reconstruction windows.\nNo threshold by default.</li>\n<li><strong>verbose</strong> (bool):\nIf True, increase verbosity of LRSDL.fit().</li>\n<li><strong>show_after</strong> (int, optional):\nIf verbose is True, show the progress every 'show_after' iterations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">y_true</span>,</span><span class=\"param\">\t<span class=\"n\">l_atoms</span>,</span><span class=\"param\">\t<span class=\"n\">iterations</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">random_seed</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_after</span><span class=\"o\">=</span><span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL.predict", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL.predict", "kind": "function", "doc": "<p>Predict the class of each window in X.</p>\n\n<p>The class of a window is the class of the closest codeword to that\nwindow in the dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (2d-array, shape=(n_signals, n_samples)):\nInput signals, with equal or more samples than the atoms'.</li>\n<li><strong>threshold</strong> (float, optional):\nLoss threshold ABOVE which signals will be marked as \"unknown\" class,\nwhich corresponds to the label value -1.\nZero by default, all signals will be classified.</li>\n<li><strong>offset</strong> (int, optional):\nIndex i0 at which to crop the input signals X.\nThe i1 will be <code>offset + l_atoms</code>. By default 0.</li>\n<li><strong>with_losses</strong> (bool, optional):\nIf True, return a tuple with the class predictions and the\ncorresponding losses.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>y_pred</strong> (1d-array, shape=(n_signals)):\nClass predictions for each input signal.</li>\n<li><strong>losses</strong> (1d-array, shape=(n_signals), optional):\nLosses of the closest codewords to each input signal.\nOnly returned if with_losses=True.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">with_losses</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.DictionaryLRSDL.save", "modulename": "clawdia.dictionaries", "qualname": "DictionaryLRSDL.save", "kind": "function", "doc": "<p>Save the dictionary to a file.</p>\n\n<p>Save the dictionary attributes using NumPy's 'np.savez()'.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file</strong> (str):\nPath to the file where to save the dictionary.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.load", "modulename": "clawdia.dictionaries", "qualname": "load", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.dictionaries.save", "modulename": "clawdia.dictionaries", "qualname": "save", "kind": "function", "doc": "<p>Same as using the dictionary's save method.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">dico</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators", "modulename": "clawdia.estimators", "kind": "module", "doc": "<p>Provides estimators and metrics for analyzing and comparing signals.</p>\n\n<p>This module includes a variety of functions to compute statistical and \nsignal-processing metrics, such as mean squared error, structural similarity \nindex, overlaps, signal-to-noise ratios, and others. Some of these functions\nare specifically adapted for gravitational-wave signal analysis, but may be \nused in broader signal-processing contexts.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p>mse(x, y)\n    Compute the Mean Squared Error between two signals.</p>\n\n<p>medse(x, y)\n    Compute the Median Squared Error between two signals.</p>\n\n<p>ssim(x, y)\n    Compute the Structural Similarity Index Measure (SSIM) between two signals.</p>\n\n<p>dssim(x, y)\n    Compute the Structural Dissimilarity between two signals.</p>\n\n<p>issim(x, y)\n    Compute the Inverse Structural Similarity Index Measure (ISSIM).</p>\n\n<p>residual(x, y)\n    Compute the norm of the difference between two signals.</p>\n\n<p>softmax(x, axis=None)\n    Compute the softmax probability distribution of the input array.</p>\n\n<p>overlap(x, y, psd, at, window=('tukey', 0.5))\n    Compute the overlap between two signals.</p>\n\n<p>ioverlap(x, y, psd, at, window=('tukey', 0.5))\n    Compute <code>1 - Overlap()</code> between two signals.</p>\n\n<p>snr(strain, *, psd, at, window=('tukey', 0.5))\n    Compute the Signal-to-Noise Ratio (SNR) of a signal.</p>\n\n<p>find_merger(h)\n    Estimate the index position of the merger in a given strain.</p>\n\n<h6 id=\"references\">References</h6>\n\n<ul>\n<li>Overlap: Badger, C. et al. (2022). DOI: 10.48550/arxiv.2210.06194</li>\n<li>Structural Similarity Index Measure (SSIM): \n<a href=\"https://en.wikipedia.org/wiki/Structural_similarity_index_measure\">https://en.wikipedia.org/wiki/Structural_similarity_index_measure</a></li>\n</ul>\n"}, {"fullname": "clawdia.estimators.mse", "modulename": "clawdia.estimators", "qualname": "mse", "kind": "function", "doc": "<p>Mean Squared Error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.medse", "modulename": "clawdia.estimators", "qualname": "medse", "kind": "function", "doc": "<p>Median Squared Error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.ssim", "modulename": "clawdia.estimators", "qualname": "ssim", "kind": "function", "doc": "<p>Structural Similarity Index Measure.</p>\n\n<p>Compute the Structural Similarity Index Measure (SSIM) between two arrays\nx and y.</p>\n\n<p>Ranges from -1 to 1:</p>\n\n<pre><code>-  1: Perfect similarity.\n\n-  0: No similarity.\n\n- -1: Perfect anti-correlation.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>x, y</strong> (array):\nInput signals.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ssim</strong> (float):\nThe Structural Similarity Index Measure between the signals x and y.</li>\n</ul>\n\n<h6 id=\"reference\">Reference</h6>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Structural_similarity_index_measure\">https://en.wikipedia.org/wiki/Structural_similarity_index_measure</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.dssim", "modulename": "clawdia.estimators", "qualname": "dssim", "kind": "function", "doc": "<p>Structural Dissimilarity.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.issim", "modulename": "clawdia.estimators", "qualname": "issim", "kind": "function", "doc": "<p>Inverse Structural SimilarityIndex Measure.</p>\n\n<p>In this case:</p>\n\n<pre><code>-  1: Perfect anti-correlation.\n\n-  0: No similarity.\n\n- -1: Perfect similarity.\n</code></pre>\n\n<p>Useful as a loss function to perform minimization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.residual", "modulename": "clawdia.estimators", "qualname": "residual", "kind": "function", "doc": "<p>Norm of the difference between 'x' and 'y'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.softmax", "modulename": "clawdia.estimators", "qualname": "softmax", "kind": "function", "doc": "<p>Softmax probability distribution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.overlap", "modulename": "clawdia.estimators", "qualname": "overlap", "kind": "function", "doc": "<p>Compute the Overlap between two signals:\n    Ov = (x|y) / sqrt((x|x) \u00b7 (y|y))</p>\n\n<p>x, y: array\n    Signals to compare.</p>\n\n<p>psd: 2d-array\n    PSD to weight the overlap, will be linearly interpolated to the right frequencies.\n    psd[0] = frequencies\n    psd[1] = psd samples</p>\n\n<p>at: float\n    Time step, inverse of sampling rate of 'x' and 'y'.</p>\n\n<p>Ref: Badger C. et al., 2022 (10.48550/arxiv.2210.06194)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">psd</span>, </span><span class=\"param\"><span class=\"n\">at</span>, </span><span class=\"param\"><span class=\"n\">window</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;tukey&#39;</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.ioverlap", "modulename": "clawdia.estimators", "qualname": "ioverlap", "kind": "function", "doc": "<p>Compute <code>1 - Overlap()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">psd</span>, </span><span class=\"param\"><span class=\"n\">at</span>, </span><span class=\"param\"><span class=\"n\">window</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;tukey&#39;</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.snr", "modulename": "clawdia.estimators", "qualname": "snr", "kind": "function", "doc": "<p>Signal to Noise Ratio.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">strain</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">psd</span>, </span><span class=\"param\"><span class=\"n\">at</span>, </span><span class=\"param\"><span class=\"n\">window</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;tukey&#39;</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.estimators.find_merger", "modulename": "clawdia.estimators", "qualname": "find_merger", "kind": "function", "doc": "<p>Estimate the index position of the merger in the given strain.</p>\n\n<p>This could be done with a better estimation model, like a gaussian in\nthe case of binary mergers. However for our current project this does not\nmake much difference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib", "modulename": "clawdia.lib", "kind": "module", "doc": "<p>Collection of auxiliary functions.</p>\n\n<p>This module provides a temporary collection of various utility functions, \nincluding mathematical operations, signal normalization, optimization routines, \nand signal patching utilities.</p>\n\n<p>As the CLAWDIA pipeline grows, these functions will be organized into more\nsemantically appropriate modules.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p>abs_normalize(array, axis=-1)\n    Normalize an array in place by its absolute maximum, ignoring division\n    errors and replacing NaNs with zeros.</p>\n\n<p>l2_normalize(array, axis=-1)\n    Normalize an array in place using the L2 norm, ignoring division errors and \n    replacing NaNs with zeros.</p>\n\n<p>semibool_bisect(f, a, b, args=(), xtol, rtol, maxiter=100, verbose=False)\n    Perform a semi-boolean bisection method to find a zero boundary for a\n    function.</p>\n\n<p>extract_patches(signals, *, patch_size, n_patches=None, random_state=None,\n                step=1, limits=None, patch_min=1, l2_normed=False,\n                return_norm_coefs=False, allow_allzeros=True)\n    Extract patches from input signals, with options for random extraction, \n    normalization, and patch-specific constraints.</p>\n\n<p>reconstruct_from_patches_1d(patches, step)\n    Reconstruct a 1D signal from its patches, using overlap-add synthesis.</p>\n"}, {"fullname": "clawdia.lib.BoundaryError", "modulename": "clawdia.lib", "qualname": "BoundaryError", "kind": "class", "doc": "<p>Inappropriate argument value (of correct type).</p>\n", "bases": "builtins.ValueError"}, {"fullname": "clawdia.lib.abs_normalize", "modulename": "clawdia.lib", "qualname": "abs_normalize", "kind": "function", "doc": "<p>TODO\nNormalitza inplace un array ignorant els errors de divissi\u00f3 entre 0 i\ncanviant els nan a 0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib.l2_normalize", "modulename": "clawdia.lib", "qualname": "l2_normalize", "kind": "function", "doc": "<p>TODO\nNormalitza inplace un array amb la norma L2 ignorant els errors de divissi\u00f3\nentre 0 i canviant els nan a 0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib.semibool_bisect", "modulename": "clawdia.lib", "qualname": "semibool_bisect", "kind": "function", "doc": "<p>TODO</p>\n\n<p>Troba x0 pel m\u00e8tode de bisecci\u00f3 adaptat a una funci\u00f3 f(x) tal que\n    f(x)  &gt; 0       x &lt;= x0,\n    f(x) == 0       x  &gt; x0,\no viceversa. Un dels dos extrems del l\u00edmite [a, b] ha de ser f(x) = 0.\nAlgorisme basat en la funci\u00f3 de bisecci\u00f3 <code>scipy.optimize.bisect</code>.</p>\n\n<p>Nota: 'rtol' controla l'ordre de precissi\u00f3 respecte 'x'.</p>\n\n<h6 id=\"result\">Result</h6>\n\n<p>solver_stats: dict\n    'x': Solution.\n    'f': Value of f(x).\n    'converged': bool.\n    'niters': Number of iterations performed.\n    'funcalls': Number of times <code>f</code> was evaluated.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">f</span>,</span><span class=\"param\">\t<span class=\"n\">a</span>,</span><span class=\"param\">\t<span class=\"n\">b</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">xtol</span><span class=\"o\">=</span><span class=\"mf\">2e-12</span>,</span><span class=\"param\">\t<span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">8.881784197001252e-16</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib.extract_patches", "modulename": "clawdia.lib", "qualname": "extract_patches", "kind": "function", "doc": "<p>Extract patches from 'signals'.</p>\n\n<p>TODO</p>\n\n<p>Note that if randomly selected, it is not prevented to repeat patches.</p>\n\n<h6 id=\"parameters\">PARAMETERS</h6>\n\n<p>signals: ndarray\n    If 2d-array, must be in C-contiguous order with shape\n    (n_signals, l_signal).</p>\n\n<p>patch_size: int\n    Length of the patches to extract.</p>\n\n<p>limits: ndarray, optional\n    Limit(s) in 'signals' such that:\n        <pre><code>i0, i1 = limits[i_signal]\nsignal = signals[i_signal, i0:i1]\n</code></pre></p>\n\n<p>patch_min: int, optional\n    When 'limits' are given, patch_min is the minimum samples inside the\n    limits to be included in the extracted patches.\n    Defaults to 1.</p>\n\n<p>n_patches: int, optional\n    Total number of patches to extract. If None (default) extract the\n    maximum amount.</p>\n\n<p>random_state: {None, int, array_like[ints], SeedSequence, BitGenerator, Generator}, optional\n    Given to 'numpy.random.PCG64(random_state)'.</p>\n\n<p>step: int, optional\n    Minimum windowing step (separation between patches).</p>\n\n<p>l2_normed: bool, optional\n    If True will norm each patch to its L2 norm. False by default.</p>\n\n<p>return_norm_coefs: bool, optional\n    If True, return also the coefficients used to normalize the signals\n    (useful for when 'signals' come from a windowed signal that will be\n    reassembled afterwards).\n    False by default.</p>\n\n<p>allow_allzeros: bool, optional\n    When extracting random patches, if False and <code>l2_normed == True</code>,\n    generate another random window position until the l2 norm is != 0.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">signals</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">patch_size</span>,</span><span class=\"param\">\t<span class=\"n\">n_patches</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">limits</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">patch_min</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">l2_normed</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">return_norm_coefs</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_allzeros</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib.reconstruct_from_patches_1d", "modulename": "clawdia.lib", "qualname": "reconstruct_from_patches_1d", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">patches</span>, </span><span class=\"param\"><span class=\"n\">step</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.lib.FINISHED", "modulename": "clawdia.lib", "qualname": "FINISHED", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;FINISHED \\n\\n\u270b\ud83d\ude0c\ud83d\udc4c&#x27;"}, {"fullname": "clawdia.pipeline", "modulename": "clawdia.pipeline", "kind": "module", "doc": "<p>Basic implementation of the pipeline model.</p>\n\n<p>The <code>Pipeline</code> class provides a minimal example of how to use CLAWDIA as a \nclassification pipeline. This implementation assumes that the dictionaries \nhave already been trained and that all necessary hyperparameters and \npost-training parameters are provided.</p>\n\n<h6 id=\"classes\">Classes</h6>\n\n<p>Pipeline\n    Implements a basic classification pipeline that preprocesses input \n    gravitational-wave strain data using a denoising dictionary and \n    subsequently classifies it using a classification dictionary.</p>\n"}, {"fullname": "clawdia.pipeline.Pipeline", "modulename": "clawdia.pipeline", "qualname": "Pipeline", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "clawdia.pipeline.Pipeline.__init__", "modulename": "clawdia.pipeline", "qualname": "Pipeline.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">dico_den</span>, </span><span class=\"param\"><span class=\"n\">dico_den_params</span>, </span><span class=\"param\"><span class=\"n\">dico_clas</span>, </span><span class=\"param\"><span class=\"n\">dico_clas_params</span></span>)</span>"}, {"fullname": "clawdia.pipeline.Pipeline.dico_den", "modulename": "clawdia.pipeline", "qualname": "Pipeline.dico_den", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.pipeline.Pipeline.dico_den_params", "modulename": "clawdia.pipeline", "qualname": "Pipeline.dico_den_params", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.pipeline.Pipeline.dico_clas", "modulename": "clawdia.pipeline", "qualname": "Pipeline.dico_clas", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.pipeline.Pipeline.dico_clas_params", "modulename": "clawdia.pipeline", "qualname": "Pipeline.dico_clas_params", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "clawdia.plotting", "modulename": "clawdia.plotting", "kind": "module", "doc": "<p>Ad-hoc plotting functions for visualizing results.</p>\n\n<p>This module includes a variety of plotting utilities designed to help visualize \nand interpret results during the development and debugging of the CLAWDIA\npipeline. </p>\n\n<p>While not essential for CLAWDIA's core processing, these functions are useful\nfor presenting and analyzing outcomes, such as confusion matrices, dictionary\natoms, and spectrograms.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p>plot_confusion(cmat, ax=None, labels=None, mode='both', vmin=None, vmax=None,\n        cmap=\"PaleBlues\", **kwargs)\n    Plot a pre-computed confusion matrix, with options for absolute values,\n    percentages, or both.</p>\n\n<p>plot_dictionary(array, c=None, ylim=None, **plot_kw)\n    Visualize dictionary atoms in a squared grid format.</p>\n\n<p>plot_spec_of(strain, figsize=(10, 5), sf=4096, window='hann', vmin=None,\n        vmax=None)\n    Plot the spectrogram of a given strain signal using a Short-Time Fourier\n    Transform (STFT).</p>\n\n<p>plot_spectrogram_with_instantaneous_features(strain_array, time_array,\n        sampling_rate=2<strong>14, outseg=None, outfreq=None,\n        window=sp.signal.windows.tukey(128, 0.5), hop=32, mfft=2</strong>14, vmin=-22,\n        ax=None)\n    Generate a multi-panel plot showing the spectrogram, instantaneous\n    frequency, and time-domain waveform of a gravitational-wave strain signal.</p>\n"}, {"fullname": "clawdia.plotting.plot_confusion", "modulename": "clawdia.plotting", "qualname": "plot_confusion", "kind": "function", "doc": "<p>Plot a confusion matrix.</p>\n\n<p>Plot a pre-computed confusion matrix <code>cmat</code>.\nRows must contain true values, and columns predicted values. For example,\nin a binary classification case:</p>\n\n<table>\n<thead>\n<tr>\n  <th>T \\ P</th>\n  <th>Pred 0</th>\n  <th>Pred 1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>True 0</td>\n  <td>TP</td>\n  <td>FN</td>\n</tr>\n<tr>\n  <td>True 1</td>\n  <td>FP</td>\n  <td>TN</td>\n</tr>\n</tbody>\n</table>\n\n<p>Where:</p>\n\n<ul>\n<li><strong>TP</strong> (True Positives): Correctly predicted Class 0.</li>\n<li><strong>FN</strong> (False Negatives): Class 0 incorrectly predicted as Class 1.</li>\n<li><strong>FP</strong> (False Positives): Class 1 incorrectly predicted as Class 0.</li>\n<li><strong>TN</strong> (True Negatives): Correctly predicted Class 1.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>cmat</strong> (array-like of shape (n_classes, n_classes)):\nThe confusion matrix to plot.</li>\n<li><strong>ax</strong> (matplotlib.axes.Axes, optional):\nThe axes on which to plot the matrix. If not given, a new figure and axes\nare created.</li>\n<li><strong>labels</strong> (list of str, optional):\nThe labels for the classes. If not given, the integers from 0 to\n<code>n_classes-1</code> are used.</li>\n<li><strong>mode</strong> ({'absolute', 'percent', 'both'}):\nThe format of the annotations: absolute numbers, percentages, or both.\nDefaults to 'both'.</li>\n<li><strong>vmin</strong> (float, optional):\nThe minimum value of the color scale.</li>\n<li><strong>vmax</strong> (float, optional):\nThe maximum value of the color scale.</li>\n<li><strong>cmap</strong> (Function (matplotlib's Colormap equivalent) | str):\nDefaults to \"PaleBlue\", a custom modification of Matplotlib's \"Blues\".</li>\n<li><strong>**kwargs</strong>: Additional keyword arguments are passed to <code>matplotlib.pyplot.subplots</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (matplotlib.figure.Figure or None):\nThe figure containing the plot, or None if <code>ax</code> was given.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cmat</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;both&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">vmax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;PaleBlues&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.plotting.plot_dictionary", "modulename": "clawdia.plotting", "qualname": "plot_dictionary", "kind": "function", "doc": "<p>Plot atoms from a dictionary in a squared matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>array</strong> (2d-array):\nDictionary matrix in Fortran order with shape (a, l).</li>\n<li><strong>c</strong> (int, optional):\nNumber of atoms at each side of the squared matrix of plots; the total\nnumber of plotted atoms will be <code>c ** 2</code>.\nIf not given, it is computed as <code>int(np.sqrt(a))</code>.</li>\n<li><strong>**plot_kw</strong> (optional):\nPassed to pyplot.subplots().</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ylim</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">plot_kw</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.plotting.plot_spec_of", "modulename": "clawdia.plotting", "qualname": "plot_spec_of", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">strain</span>,</span><span class=\"param\">\t<span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">sf</span><span class=\"o\">=</span><span class=\"mi\">4096</span>,</span><span class=\"param\">\t<span class=\"n\">window</span><span class=\"o\">=</span><span class=\"s1\">&#39;hann&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vmin</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">vmax</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "clawdia.plotting.plot_spectrogram_with_instantaneous_features", "modulename": "clawdia.plotting", "qualname": "plot_spectrogram_with_instantaneous_features", "kind": "function", "doc": "<p>Plot the spectrogram, instantaneous frequency, and strain's waveform.</p>\n\n<p>This function generates a multi-panel plot consisting of:</p>\n\n<ol>\n<li>A spectrogram of the gravitational wave strain, obtained using\nShort-Time Fourier Transform (STFT), visualizing the frequency evolution\nover time.</li>\n<li>The instantaneous frequency of the strain, plotted on top of the\nspectrogram to show the frequency changes in real time.</li>\n<li>The raw gravitational wave strain in the time domain, shown above the\nspectrogram for direct comparison.</li>\n</ol>\n\n<p>Key features of the plot:</p>\n\n<ul>\n<li><strong>Spectrogram</strong>: The frequency content of the gravitational wave signal\nis displayed over time using a color map (<code>inferno</code>), with the x-axis\nrepresenting time (in milliseconds) and the y-axis representing\nfrequency (in Hz).</li>\n<li><strong>Instantaneous Frequency</strong>: Plots the instantaneous frequency of the\nstrain over time, highlighting the frequency variations.</li>\n<li><strong>Energy Normalization</strong>: The spectrogram uses a logarithmic scale for\nthe energy (power spectral density, PSD), normalized by the maximum\nenergy value in the signal.</li>\n<li><strong>Dynamic Range Control</strong>: The color scale of the spectrogram can be\nadjusted via the <code>vmin</code> parameter to emphasize specific energy levels.</li>\n<li><strong>Time-Domain Waveform</strong>: A plot of the original strain data in the time\ndomain is shown above the spectrogram, providing context for the signal's\nevolution.</li>\n<li><strong>Segmentation</strong>: The user can specify the time (<code>outseg</code>) and frequency\n(<code>outfreq</code>) ranges to focus on specific parts of the data.</li>\n<li><strong>Customization</strong>: The plot has a black background, white grid lines,\nand labeled colorbars for clarity.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>strain_array</strong> (numpy.ndarray):\nThe time-domain strain data of the gravitational wave signal.</li>\n<li><strong>time_array</strong> (numpy.ndarray):\nArray of time stamps corresponding to the strain data.</li>\n<li><strong>sampling_rate</strong> (int, optional):\nThe sampling rate of the data in Hz (default is 2^14, or 16384 Hz).</li>\n<li><strong>outseg</strong> (tuple, optional):\nA tuple specifying the time range (start, end) in seconds for the\nx-axis. If <code>None</code>, the entire time range of the input data is used.</li>\n<li><strong>outfreq</strong> (tuple, optional):\nA tuple specifying the frequency range (start, end) in Hz for the\ny-axis. If <code>None</code>, the full frequency range (up to Nyquist frequency)\nis used.</li>\n<li><strong>window</strong> (numpy.ndarray, optional):\nThe window function applied during STFT computation (default is a\nTukey window).</li>\n<li><strong>hop</strong> (int, optional):\nThe hop size between successive STFT windows (default is 32).</li>\n<li><strong>mfft</strong> (int, optional):\nThe number of points in the FFT used for STFT computation (default\nis 2^14).</li>\n<li><strong>vmin</strong> (float, optional):\nThe minimum value for the color scale in the spectrogram (default\nis -22). This controls the dynamic range of the color map.</li>\n<li><strong>ax</strong> (matplotlib.axes.Axes, optional):\nThe axes object on which to plot the spectrogram. If <code>None</code>, a new\nfigure and axes are created.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (matplotlib.figure.Figure):\nThe figure object containing the complete plot.</li>\n<li><strong>axs</strong> (List[matplotlib.axes.Axes]):\nA list of axes objects containing the spectrogram, the colorbar, and\nthe time-domain plots.</li>\n<li><strong>Sxx</strong> (numpy.ndarray):\nThe computed spectrogram (PSD values) of the input strain data.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>The spectrogram normalization is performed on the square root of the \nPower Spectral Density (PSD), converted to a logarithmic scale.</li>\n<li>The y-axis of the spectrogram uses a kilohertz scale for readability.</li>\n<li>The time-domain waveform is plotted without axes labels for simplicity.</li>\n<li>Instantaneous frequency values below zero are masked to avoid displaying \nnon-physical results.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">strain_array</span>,</span><span class=\"param\">\t<span class=\"n\">time_array</span>,</span><span class=\"param\">\t<span class=\"n\">sampling_rate</span><span class=\"o\">=</span><span class=\"mi\">16384</span>,</span><span class=\"param\">\t<span class=\"n\">outseg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">outfreq</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">window</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.</span>        <span class=\"p\">,</span> <span class=\"mf\">0.00244567</span><span class=\"p\">,</span> <span class=\"mf\">0.00975876</span><span class=\"p\">,</span> <span class=\"mf\">0.02186772</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.03865409</span><span class=\"p\">,</span> <span class=\"mf\">0.05995367</span><span class=\"p\">,</span> <span class=\"mf\">0.08555808</span><span class=\"p\">,</span> <span class=\"mf\">0.11521684</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.14863981</span><span class=\"p\">,</span> <span class=\"mf\">0.18550003</span><span class=\"p\">,</span> <span class=\"mf\">0.2254369</span> <span class=\"p\">,</span> <span class=\"mf\">0.26805974</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.31295157</span><span class=\"p\">,</span> <span class=\"mf\">0.35967324</span><span class=\"p\">,</span> <span class=\"mf\">0.40776768</span><span class=\"p\">,</span> <span class=\"mf\">0.4567644</span> <span class=\"p\">,</span>\n       <span class=\"mf\">0.50618408</span><span class=\"p\">,</span> <span class=\"mf\">0.55554326</span><span class=\"p\">,</span> <span class=\"mf\">0.60435908</span><span class=\"p\">,</span> <span class=\"mf\">0.65215399</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.69846043</span><span class=\"p\">,</span> <span class=\"mf\">0.74282539</span><span class=\"p\">,</span> <span class=\"mf\">0.78481486</span><span class=\"p\">,</span> <span class=\"mf\">0.82401809</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.86005154</span><span class=\"p\">,</span> <span class=\"mf\">0.89256273</span><span class=\"p\">,</span> <span class=\"mf\">0.9212336</span> <span class=\"p\">,</span> <span class=\"mf\">0.94578368</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.9659728</span> <span class=\"p\">,</span> <span class=\"mf\">0.98160345</span><span class=\"p\">,</span> <span class=\"mf\">0.99252273</span><span class=\"p\">,</span> <span class=\"mf\">0.99862382</span><span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"mf\">1.</span>        <span class=\"p\">,</span>\n       <span class=\"mf\">0.99862382</span><span class=\"p\">,</span> <span class=\"mf\">0.99252273</span><span class=\"p\">,</span> <span class=\"mf\">0.98160345</span><span class=\"p\">,</span> <span class=\"mf\">0.9659728</span> <span class=\"p\">,</span>\n       <span class=\"mf\">0.94578368</span><span class=\"p\">,</span> <span class=\"mf\">0.9212336</span> <span class=\"p\">,</span> <span class=\"mf\">0.89256273</span><span class=\"p\">,</span> <span class=\"mf\">0.86005154</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.82401809</span><span class=\"p\">,</span> <span class=\"mf\">0.78481486</span><span class=\"p\">,</span> <span class=\"mf\">0.74282539</span><span class=\"p\">,</span> <span class=\"mf\">0.69846043</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.65215399</span><span class=\"p\">,</span> <span class=\"mf\">0.60435908</span><span class=\"p\">,</span> <span class=\"mf\">0.55554326</span><span class=\"p\">,</span> <span class=\"mf\">0.50618408</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.4567644</span> <span class=\"p\">,</span> <span class=\"mf\">0.40776768</span><span class=\"p\">,</span> <span class=\"mf\">0.35967324</span><span class=\"p\">,</span> <span class=\"mf\">0.31295157</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.26805974</span><span class=\"p\">,</span> <span class=\"mf\">0.2254369</span> <span class=\"p\">,</span> <span class=\"mf\">0.18550003</span><span class=\"p\">,</span> <span class=\"mf\">0.14863981</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.11521684</span><span class=\"p\">,</span> <span class=\"mf\">0.08555808</span><span class=\"p\">,</span> <span class=\"mf\">0.05995367</span><span class=\"p\">,</span> <span class=\"mf\">0.03865409</span><span class=\"p\">,</span>\n       <span class=\"mf\">0.02186772</span><span class=\"p\">,</span> <span class=\"mf\">0.00975876</span><span class=\"p\">,</span> <span class=\"mf\">0.00244567</span><span class=\"p\">,</span> <span class=\"mf\">0.</span>        <span class=\"p\">])</span>,</span><span class=\"param\">\t<span class=\"n\">hop</span><span class=\"o\">=</span><span class=\"mi\">32</span>,</span><span class=\"param\">\t<span class=\"n\">mfft</span><span class=\"o\">=</span><span class=\"mi\">16384</span>,</span><span class=\"param\">\t<span class=\"n\">vmin</span><span class=\"o\">=-</span><span class=\"mi\">22</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();